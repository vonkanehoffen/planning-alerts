# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"mutation root"
type mutation_root {
  "delete data from the table: \"planning_app\""
  delete_planning_app(
    #filter the rows which have to be deleted
    where: planning_app_bool_exp!
  ): planning_app_mutation_response
  "delete data from the table: \"users\""
  delete_users(
    #filter the rows which have to be deleted
    where: users_bool_exp!
  ): users_mutation_response
  "insert data into the table: \"planning_app\""
  insert_planning_app(
    #the rows to be inserted
    objects: [planning_app_insert_input!]!,
    #on conflict condition
    on_conflict: planning_app_on_conflict
  ): planning_app_mutation_response
  "insert data into the table: \"users\""
  insert_users(
    #the rows to be inserted
    objects: [users_insert_input!]!,
    #on conflict condition
    on_conflict: users_on_conflict
  ): users_mutation_response
  "update data of the table: \"planning_app\""
  update_planning_app(
    #append existing jsonb value of filtered columns with new jsonb value
    _append: planning_app_append_input,
    #delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: planning_app_delete_at_path_input,
    #delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: planning_app_delete_elem_input,
    #delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: planning_app_delete_key_input,
    #prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: planning_app_prepend_input,
    #sets the columns of the filtered rows to the given values
    _set: planning_app_set_input,
    #filter the rows which have to be updated
    where: planning_app_bool_exp!
  ): planning_app_mutation_response
  "update data of the table: \"users\""
  update_users(
    #sets the columns of the filtered rows to the given values
    _set: users_set_input,
    #filter the rows which have to be updated
    where: users_bool_exp!
  ): users_mutation_response
}

"columns and relationships of \"planning_app\""
type planning_app {
  address: String!
  alternative_ref: String
  appeal_decision: String
  appeal_status: String
  created_at: timestamptz!
  decision_date: date
  decision_status: String
  geocode_ok: Boolean
  location: geography
  previousData(
    #JSON select path
    path: String
  ): jsonb
  proposal: String!
  ref: String!
  updated_at: timestamptz
  url: String!
  validated_date: date
}

"aggregated selection of \"planning_app\""
type planning_app_aggregate {
  aggregate: planning_app_aggregate_fields
  nodes: [planning_app!]!
}

"aggregate fields of \"planning_app\""
type planning_app_aggregate_fields {
  count(columns: [planning_app_select_column!], distinct: Boolean): Int
  max: planning_app_max_fields
  min: planning_app_min_fields
}

"aggregate max on columns"
type planning_app_max_fields {
  address: String
  alternative_ref: String
  appeal_decision: String
  appeal_status: String
  created_at: timestamptz
  decision_date: date
  decision_status: String
  proposal: String
  ref: String
  updated_at: timestamptz
  url: String
  validated_date: date
}

"aggregate min on columns"
type planning_app_min_fields {
  address: String
  alternative_ref: String
  appeal_decision: String
  appeal_status: String
  created_at: timestamptz
  decision_date: date
  decision_status: String
  proposal: String
  ref: String
  updated_at: timestamptz
  url: String
  validated_date: date
}

"response of any mutation on the table \"planning_app\""
type planning_app_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [planning_app!]!
}

"query root"
type query_root {
  "fetch data from the table: \"planning_app\""
  planning_app(
    #distinct select on columns
    distinct_on: [planning_app_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [planning_app_order_by!],
    #filter the rows returned
    where: planning_app_bool_exp
  ): [planning_app!]!
  "fetch aggregated fields from the table: \"planning_app\""
  planning_app_aggregate(
    #distinct select on columns
    distinct_on: [planning_app_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [planning_app_order_by!],
    #filter the rows returned
    where: planning_app_bool_exp
  ): planning_app_aggregate!
  "fetch data from the table: \"planning_app\" using primary key columns"
  planning_app_by_pk(ref: String!): planning_app
  "fetch data from the table: \"users\""
  users(
    #distinct select on columns
    distinct_on: [users_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [users_order_by!],
    #filter the rows returned
    where: users_bool_exp
  ): [users!]!
  "fetch aggregated fields from the table: \"users\""
  users_aggregate(
    #distinct select on columns
    distinct_on: [users_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [users_order_by!],
    #filter the rows returned
    where: users_bool_exp
  ): users_aggregate!
  "fetch data from the table: \"users\" using primary key columns"
  users_by_pk(id: String!): users
}

"subscription root"
type subscription_root {
  "fetch data from the table: \"planning_app\""
  planning_app(
    #distinct select on columns
    distinct_on: [planning_app_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [planning_app_order_by!],
    #filter the rows returned
    where: planning_app_bool_exp
  ): [planning_app!]!
  "fetch aggregated fields from the table: \"planning_app\""
  planning_app_aggregate(
    #distinct select on columns
    distinct_on: [planning_app_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [planning_app_order_by!],
    #filter the rows returned
    where: planning_app_bool_exp
  ): planning_app_aggregate!
  "fetch data from the table: \"planning_app\" using primary key columns"
  planning_app_by_pk(ref: String!): planning_app
  "fetch data from the table: \"users\""
  users(
    #distinct select on columns
    distinct_on: [users_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [users_order_by!],
    #filter the rows returned
    where: users_bool_exp
  ): [users!]!
  "fetch aggregated fields from the table: \"users\""
  users_aggregate(
    #distinct select on columns
    distinct_on: [users_select_column!],
    #limit the number of rows returned
    limit: Int,
    #skip the first n rows. Use only with order_by
    offset: Int,
    #sort the rows by one or more columns
    order_by: [users_order_by!],
    #filter the rows returned
    where: users_bool_exp
  ): users_aggregate!
  "fetch data from the table: \"users\" using primary key columns"
  users_by_pk(id: String!): users
}

"columns and relationships of \"users\""
type users {
  email: String
  id: String!
  location: geography
  name: String
}

"aggregated selection of \"users\""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"aggregate max on columns"
type users_max_fields {
  email: String
  id: String
  name: String
}

"aggregate min on columns"
type users_min_fields {
  email: String
  id: String
  name: String
}

"response of any mutation on the table \"users\""
type users_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [users!]!
}

"column ordering options"
enum order_by {
  #in the ascending order, nulls last
  asc
  #in the ascending order, nulls first
  asc_nulls_first
  #in the ascending order, nulls last
  asc_nulls_last
  #in the descending order, nulls first
  desc
  #in the descending order, nulls first
  desc_nulls_first
  #in the descending order, nulls last
  desc_nulls_last
}

"unique or primary key constraints on table \"planning_app\""
enum planning_app_constraint {
  #unique or primary key constraint
  planning_app_pkey
  #unique or primary key constraint
  planning_app_ref_key
}

"select columns of table \"planning_app\""
enum planning_app_select_column {
  #column name
  address
  #column name
  alternative_ref
  #column name
  appeal_decision
  #column name
  appeal_status
  #column name
  created_at
  #column name
  decision_date
  #column name
  decision_status
  #column name
  geocode_ok
  #column name
  location
  #column name
  previousData
  #column name
  proposal
  #column name
  ref
  #column name
  updated_at
  #column name
  url
  #column name
  validated_date
}

"update columns of table \"planning_app\""
enum planning_app_update_column {
  #column name
  address
  #column name
  alternative_ref
  #column name
  appeal_decision
  #column name
  appeal_status
  #column name
  created_at
  #column name
  decision_date
  #column name
  decision_status
  #column name
  geocode_ok
  #column name
  location
  #column name
  previousData
  #column name
  proposal
  #column name
  ref
  #column name
  updated_at
  #column name
  url
  #column name
  validated_date
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
  #unique or primary key constraint
  users_pkey
}

"select columns of table \"users\""
enum users_select_column {
  #column name
  email
  #column name
  id
  #column name
  location
  #column name
  name
}

"update columns of table \"users\""
enum users_update_column {
  #column name
  email
  #column name
  id
  #column name
  location
  #column name
  name
}

"expression to compare columns of type Boolean. All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"expression to compare columns of type date. All fields are combined with logical 'AND'."
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"Expression to compare the result of casting a column of type geography. Multiple cast targets are combined with logical 'AND'."
input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"expression to compare columns of type geography. All fields are combined with logical 'AND'."
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]
  "is the column within a distance from a geography value"
  _st_d_within: st_d_within_geography_input
  "does the column spatially intersect the given geography value"
  _st_intersects: geography
}

"Expression to compare the result of casting a column of type geometry. Multiple cast targets are combined with logical 'AND'."
input geometry_cast_exp {
  geography: geography_comparison_exp
}

"expression to compare columns of type geometry. All fields are combined with logical 'AND'."
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]
  "does the column contain the given geometry value"
  _st_contains: geometry
  "does the column crosses the given geometry value"
  _st_crosses: geometry
  "is the column within a distance from a geometry value"
  _st_d_within: st_d_within_input
  "is the column equal to given geometry value. Directionality is ignored"
  _st_equals: geometry
  "does the column spatially intersect the given geometry value"
  _st_intersects: geometry
  "does the column 'spatially overlap' (intersect but not completely contain) the given geometry value"
  _st_overlaps: geometry
  "does the column have atleast one point in common with the given geometry value"
  _st_touches: geometry
  "is the column contained in the given geometry value"
  _st_within: geometry
}

"expression to compare columns of type jsonb. All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"order by aggregate values of table \"planning_app\""
input planning_app_aggregate_order_by {
  count: order_by
  max: planning_app_max_order_by
  min: planning_app_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input planning_app_append_input {
  previousData: jsonb
}

"input type for inserting array relation for remote table \"planning_app\""
input planning_app_arr_rel_insert_input {
  data: [planning_app_insert_input!]!
  on_conflict: planning_app_on_conflict
}

"Boolean expression to filter rows from the table \"planning_app\". All fields are combined with a logical 'AND'."
input planning_app_bool_exp {
  _and: [planning_app_bool_exp]
  _not: planning_app_bool_exp
  _or: [planning_app_bool_exp]
  address: String_comparison_exp
  alternative_ref: String_comparison_exp
  appeal_decision: String_comparison_exp
  appeal_status: String_comparison_exp
  created_at: timestamptz_comparison_exp
  decision_date: date_comparison_exp
  decision_status: String_comparison_exp
  geocode_ok: Boolean_comparison_exp
  location: geography_comparison_exp
  previousData: jsonb_comparison_exp
  proposal: String_comparison_exp
  ref: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
  validated_date: date_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input planning_app_delete_at_path_input {
  previousData: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input planning_app_delete_elem_input {
  previousData: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input planning_app_delete_key_input {
  previousData: String
}

"input type for inserting data into table \"planning_app\""
input planning_app_insert_input {
  address: String
  alternative_ref: String
  appeal_decision: String
  appeal_status: String
  created_at: timestamptz
  decision_date: date
  decision_status: String
  geocode_ok: Boolean
  location: geography
  previousData: jsonb
  proposal: String
  ref: String
  updated_at: timestamptz
  url: String
  validated_date: date
}

"order by max() on columns of table \"planning_app\""
input planning_app_max_order_by {
  address: order_by
  alternative_ref: order_by
  appeal_decision: order_by
  appeal_status: order_by
  created_at: order_by
  decision_date: order_by
  decision_status: order_by
  proposal: order_by
  ref: order_by
  updated_at: order_by
  url: order_by
  validated_date: order_by
}

"order by min() on columns of table \"planning_app\""
input planning_app_min_order_by {
  address: order_by
  alternative_ref: order_by
  appeal_decision: order_by
  appeal_status: order_by
  created_at: order_by
  decision_date: order_by
  decision_status: order_by
  proposal: order_by
  ref: order_by
  updated_at: order_by
  url: order_by
  validated_date: order_by
}

"input type for inserting object relation for remote table \"planning_app\""
input planning_app_obj_rel_insert_input {
  data: planning_app_insert_input!
  on_conflict: planning_app_on_conflict
}

"on conflict condition type for table \"planning_app\""
input planning_app_on_conflict {
  constraint: planning_app_constraint!
  update_columns: [planning_app_update_column!]!
  where: planning_app_bool_exp
}

"ordering options when selecting data from \"planning_app\""
input planning_app_order_by {
  address: order_by
  alternative_ref: order_by
  appeal_decision: order_by
  appeal_status: order_by
  created_at: order_by
  decision_date: order_by
  decision_status: order_by
  geocode_ok: order_by
  location: order_by
  previousData: order_by
  proposal: order_by
  ref: order_by
  updated_at: order_by
  url: order_by
  validated_date: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input planning_app_prepend_input {
  previousData: jsonb
}

"input type for updating data in table \"planning_app\""
input planning_app_set_input {
  address: String
  alternative_ref: String
  appeal_decision: String
  appeal_status: String
  created_at: timestamptz
  decision_date: date
  decision_status: String
  geocode_ok: Boolean
  location: geography
  previousData: jsonb
  proposal: String
  ref: String
  updated_at: timestamptz
  url: String
  validated_date: date
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"order by aggregate values of table \"users\""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"input type for inserting array relation for remote table \"users\""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  email: String_comparison_exp
  id: String_comparison_exp
  location: geography_comparison_exp
  name: String_comparison_exp
}

"input type for inserting data into table \"users\""
input users_insert_input {
  email: String
  id: String
  location: geography
  name: String
}

"order by max() on columns of table \"users\""
input users_max_order_by {
  email: order_by
  id: order_by
  name: order_by
}

"order by min() on columns of table \"users\""
input users_min_order_by {
  email: order_by
  id: order_by
  name: order_by
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"on conflict condition type for table \"users\""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"ordering options when selecting data from \"users\""
input users_order_by {
  email: order_by
  id: order_by
  location: order_by
  name: order_by
}

"input type for updating data in table \"users\""
input users_set_input {
  email: String
  id: String
  location: geography
  name: String
}


scalar date

scalar geography

scalar geometry

scalar jsonb

scalar timestamptz